{"version":3,"file":"sleet-handlebars.min.js","sources":["../../sleet-html/lib/compilers/tag.js","../../sleet-html/lib/compilers/text.js","../../sleet-html/lib/compilers/other-tags.js","../../sleet-html/lib/compilers/values.js","../../sleet-html/lib/compilers/attribute.js","../../sleet-html/lib/compilers/include.js","../../sleet-html/lib/compilers/mixin.js","../../sleet-html/lib/index.js","../src/compilers/block-tag.ts","../src/compilers/attributes.ts","../src/compilers/tag.ts","../src/compilers/inline-tag.ts","../src/compilers/helper.ts","../src/compilers/text.ts","../src/index.ts"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sleet_1 = require(\"sleet\");\nclass TagCompiler extends sleet_1.AbstractCompiler {\n    static create(node, stack) {\n        return new TagCompiler(node, stack);\n    }\n    compile(context, ...others) {\n        this.tagOpen(context);\n        this.content(context);\n        this.tagClose(context);\n    }\n    tagOpen(context) {\n        this.openStart(context);\n        this.attributes(context);\n        this.openEnd(context);\n    }\n    openStart(context) {\n        context.eol().indent().push('<');\n        if (this.node.namespace) {\n            context.push(this.node.namespace).push(':');\n        }\n        context.push(this.node.name || 'div');\n    }\n    attributes(context) {\n        const groups = this.mergeAttributeGroup(context, ...[this.dotsAndHash()].concat(this.node.attributeGroups));\n        if (groups.length)\n            context.push(' ');\n        groups.forEach((it, idx) => {\n            const sub = context.compile(it, this.stack);\n            if (sub) {\n                if (idx)\n                    context.push(' ');\n                sub.mergeUp();\n            }\n        });\n    }\n    openEnd(context) {\n        context.push('>');\n    }\n    content(context) {\n        if (this.selfClosing())\n            return;\n        this.node.children.forEach(it => context.compileUp(it, this.stack));\n    }\n    tagClose(context) {\n        if (this.selfClosing())\n            return;\n        if (context.haveIndent)\n            context.eol().indent();\n        context.push('</');\n        if (this.node.namespace) {\n            context.push(this.node.namespace).push(':');\n        }\n        context.push(this.node.name || 'div').push('>');\n    }\n    selfClosing() {\n        return false;\n    }\n    dotsAndHash() {\n        if (!this.node.hash && !this.node.dots.length)\n            return null;\n        const s = this.node.location.start;\n        let e;\n        if (this.node.attributeGroups.length) {\n            e = this.node.attributeGroups[0].location.start;\n        }\n        else {\n            e = this.node.location.end;\n        }\n        const location = {\n            start: { offset: s.offset, line: s.line, column: s.column },\n            end: { offset: e.offset, line: e.line, column: e.column }\n        };\n        const attrs = [];\n        if (this.node.hash) {\n            const value = [new sleet_1.StringValue(this.node.hash, location)];\n            attrs.push(new sleet_1.Attribute(undefined, 'id', value, location));\n        }\n        if (this.node.dots.length) {\n            const value = this.node.dots.map(it => new sleet_1.StringValue(it, location));\n            attrs.push(new sleet_1.Attribute(undefined, 'class', value, location));\n        }\n        return new sleet_1.AttributeGroup(attrs, undefined, location);\n    }\n    mergeAttributeGroup(context, ...groups) {\n        const gs = groups.filter(it => !!it);\n        if (!gs.length)\n            return [];\n        if (context.options.ignoreSetting !== false) {\n            return [gs.reduce((acc, item) => {\n                    acc.merge(item, true);\n                    return acc;\n                })];\n        }\n        const ns = gs.filter(it => !it.setting);\n        if (!ns.length)\n            return gs;\n        return gs.filter(it => !!it.setting).concat(ns.reduce((acc, item) => {\n            acc.merge(item);\n            return acc;\n        }));\n    }\n}\nTagCompiler.type = sleet_1.NodeType.Tag;\nexports.TagCompiler = TagCompiler;\nconst emptyTags = [\n    'area', 'base', 'br', 'col', 'command',\n    'embed', 'hr', 'img', 'input', 'keygen',\n    'link', 'meta', 'param', 'source', 'track', 'wbr'\n];\nclass EmptyTagCompiler extends TagCompiler {\n    static create(node, stack) {\n        const tag = node;\n        if (!tag.name || emptyTags.indexOf(tag.name) === -1)\n            return undefined;\n        return new EmptyTagCompiler(tag, stack);\n    }\n    selfClosing() {\n        return true;\n    }\n}\nexports.EmptyTagCompiler = EmptyTagCompiler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sleet_1 = require(\"sleet\");\nconst map = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    '\\'': '&#39;',\n    '/': '&#x2F;',\n    '`': '&#x60;',\n    '=': '&#x3D;'\n};\nconst escapeHtml = (string) => string.replace(/[&<>\"'`=\\/]/g, s => map[s]);\nclass TextCompiler extends sleet_1.AbstractCompiler {\n    static create(node, stack) {\n        if (node.name === '|')\n            return new TextCompiler(node, stack);\n    }\n    compile(context) {\n        if (!this.node.text.length)\n            return;\n        const escape = this.escape();\n        const lines = this.node.text.filter(it => !!it.length);\n        if (!this.inline())\n            context.eol();\n        lines.forEach(line => {\n            const txt = line.map(it => it.toHTMLString()).join('');\n            if (txt.length) {\n                if (!this.inline())\n                    context.indent();\n                context.push(escape ? escapeHtml(txt) : txt);\n            }\n            context.eol();\n        });\n        context.pop();\n    }\n    escape() {\n        return this.node.namespace === 'escape';\n    }\n    inline() {\n        return this.node.namespace === 'inline';\n    }\n}\nTextCompiler.type = sleet_1.NodeType.Tag;\nexports.TextCompiler = TextCompiler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sleet_1 = require(\"sleet\");\nconst tag_1 = require(\"./tag\");\nclass CommentCompiler extends tag_1.TagCompiler {\n    static create(node, stack) {\n        if (node.name === '#')\n            return new CommentCompiler(node, stack);\n    }\n    tagOpen(context) {\n        context.eol().indent().push('<!--');\n        if (this.inline())\n            context.push(' ');\n    }\n    tagClose(context) {\n        if (context.haveIndent)\n            context.eol().indent();\n        if (this.inline())\n            context.push(' ');\n        context.push('-->');\n    }\n    inline() {\n        const node = this.node.children[0];\n        return node && node.namespace === 'inline';\n    }\n}\nexports.CommentCompiler = CommentCompiler;\nclass DoctypeCompiler extends tag_1.TagCompiler {\n    static create(node, stack) {\n        if (node.name === 'doctype')\n            return new DoctypeCompiler(node, stack);\n    }\n    compile(context) {\n        context.eol().indent().push('<!DOCTYPE html>');\n    }\n}\nexports.DoctypeCompiler = DoctypeCompiler;\nclass IeifCompiler extends tag_1.TagCompiler {\n    static create(node, stack) {\n        const tag = node;\n        if (tag.name === 'ieif')\n            return new IeifCompiler(tag, stack, false);\n        if (tag.name === '@ieif')\n            return new IeifCompiler(tag, stack, true);\n    }\n    constructor(node, stack, closeIt = false) {\n        super(node, stack);\n        this.closeIt = closeIt;\n    }\n    openStart(context) {\n        context.eol().indent().push('<!--[if ');\n    }\n    openEnd(context) {\n        context.push(this.closeIt ? ']><!-->' : ']>');\n    }\n    attributes(context) {\n        if (this.node.attributeGroups.length) {\n            const attr = this.node.attributeGroups[0].attributes[0];\n            if (attr && attr.values[0] && attr.values[0] instanceof sleet_1.StringValue) {\n                const v = attr.values[0];\n                context.push(v.value);\n            }\n        }\n    }\n    tagClose(context) {\n        if (context.haveIndent)\n            context.eol().indent();\n        context.push(this.closeIt ? '<!--<![endif]-->' : '<![endif]-->');\n    }\n}\nexports.IeifCompiler = IeifCompiler;\nclass EchoCompiler extends tag_1.TagCompiler {\n    static create(node, stack) {\n        if (node.name === 'echo')\n            return new EchoCompiler(node, stack);\n    }\n    compile(context) {\n        if (!this.node.attributeGroups.length)\n            return;\n        context.eol().indent();\n        this.node.attributeGroups.forEach(it => it.attributes.forEach(attr => attr.values.forEach(v => {\n            const stack = this.stack.concat([it, attr]);\n            context.compileUp(v, stack);\n        })));\n    }\n}\nexports.EchoCompiler = EchoCompiler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sleet_1 = require(\"sleet\");\nclass ValueCompiler {\n    constructor(value) {\n        this.value = value;\n    }\n    compile(context) {\n        context.push(this.value.value);\n    }\n}\nclass StringValueCompiler extends ValueCompiler {\n    static create(node) {\n        return new StringValueCompiler(node);\n    }\n}\nStringValueCompiler.type = sleet_1.NodeType.StringValue;\nexports.StringValueCompiler = StringValueCompiler;\nclass BooleanValueCompiler extends ValueCompiler {\n    static create(node) {\n        return new BooleanValueCompiler(node);\n    }\n}\nBooleanValueCompiler.type = sleet_1.NodeType.BooleanValue;\nexports.BooleanValueCompiler = BooleanValueCompiler;\nclass NumberValueCompiler extends ValueCompiler {\n    static create(node) {\n        return new NumberValueCompiler(node);\n    }\n}\nNumberValueCompiler.type = sleet_1.NodeType.NumberValue;\nexports.NumberValueCompiler = NumberValueCompiler;\nclass IdentifierValueCompiler extends ValueCompiler {\n    static create(node) {\n        return new IdentifierValueCompiler(node);\n    }\n}\nIdentifierValueCompiler.type = sleet_1.NodeType.IdentifierValue;\nexports.IdentifierValueCompiler = IdentifierValueCompiler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sleet_1 = require(\"sleet\");\nclass AttributeGroupCompiler extends sleet_1.AbstractCompiler {\n    static create(node, stack) {\n        return new AttributeGroupCompiler(node, stack);\n    }\n    compile(context) {\n        this.node.attributes.forEach((it, idx) => {\n            const sub = context.compile(it, this.stack);\n            if (!sub)\n                return;\n            if (idx)\n                context.push(' ');\n            sub.mergeUp();\n        });\n    }\n}\nAttributeGroupCompiler.type = sleet_1.NodeType.AttributeGroup;\nexports.AttributeGroupCompiler = AttributeGroupCompiler;\nclass AttributeCompiler extends sleet_1.AbstractCompiler {\n    static create(node, stack) {\n        return new AttributeCompiler(node, stack);\n    }\n    compile(context) {\n        let k = this.key(context);\n        const v = this.value(context);\n        if (!k)\n            k = v;\n        context.push(k).push('=\"').push(v).push('\"');\n    }\n    key(context) {\n        let result = '';\n        if (this.node.namespace && this.node.name)\n            result += this.node.namespace + ':';\n        if (this.node.name)\n            result += this.node.name;\n        return result;\n    }\n    value(context) {\n        const vs = this.node.values.map(it => {\n            const sub = context.compile(it, this.stack);\n            return sub ? sub.getOutput() : '';\n        });\n        return this.node.name === 'class' ? vs.join(' ') : vs.join('');\n    }\n}\nAttributeCompiler.type = sleet_1.NodeType.Attribute;\nexports.AttributeCompiler = AttributeCompiler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst tag_1 = require(\"./tag\");\nconst sleet_1 = require(\"sleet\");\nclass IncludeCompiler extends tag_1.TagCompiler {\n    static create(node, stack) {\n        if (node.name === '@include')\n            return new IncludeCompiler(node, stack);\n    }\n    compile(context) {\n        let dir = context.options.sourceFile || path.resolve('.');\n        if (fs.statSync(dir).isFile())\n            dir = path.dirname(dir);\n        const file = path.resolve(dir, this.getPath());\n        const { nodes } = sleet_1.parse(fs.readFileSync(file, 'utf-8'));\n        nodes.forEach(it => context.compileUp(it, this.stack, -1));\n    }\n    getPath() {\n        if (this.node.attributeGroups.length) {\n            const v = this.node.attributeGroups[0].attributes[0].values[0];\n            if (v) {\n                if (v instanceof sleet_1.StringValue)\n                    return v.value;\n                if (v instanceof sleet_1.IdentifierValue)\n                    return v.value;\n            }\n        }\n        const { line, column } = this.node.location.start;\n        throw new SyntaxError(`no file specified, line: ${line} column: ${column}`);\n    }\n}\nexports.IncludeCompiler = IncludeCompiler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tag_1 = require(\"./tag\");\nclass MixinDefineCompiler extends tag_1.TagCompiler {\n    static create(node, stack) {\n        if (node.name === '@mixin')\n            return new MixinDefineCompiler(node, stack);\n    }\n    compile(context) {\n        if (!this.node.hash) {\n            throw new Error('Hash property is required for mixin definition. eg. @mixin#name');\n        }\n        if (this.node.indent !== 0) {\n            throw new Error('Mixin definition must be placed in top level(the indent of it must be 0)');\n        }\n        if (!context.note.mixin)\n            context.note.mixin = {};\n        if (context.note.mixin[this.node.hash]) {\n            throw new Error(`Mixin definition #${this.node.hash} have already defined`);\n        }\n        context.note.mixin[this.node.hash] = {\n            nodes: this.node.children,\n            replacement: this.replacement(context)\n        };\n    }\n    replacement(context) {\n        if (!this.node.attributeGroups.length)\n            return {};\n        const attrs = this.node.attributeGroups[0].attributes;\n        return attrs.reduce((acc, it) => {\n            const v = it.values[0];\n            if (!v)\n                return acc;\n            const stack = this.stack.concat([this.node.attributeGroups[0], it]);\n            const sub = context.compile(v, stack);\n            if (!sub)\n                return acc;\n            const vv = sub.getOutput();\n            it.name ? acc[it.name] = vv : acc[vv] = null;\n            return acc;\n        }, {});\n    }\n}\nexports.MixinDefineCompiler = MixinDefineCompiler;\nclass MixinReferenceCompiler extends MixinDefineCompiler {\n    static create(node, stack) {\n        if (node.name === 'mixin')\n            return new MixinReferenceCompiler(node, stack);\n    }\n    compile(context) {\n        if (!this.node.hash) {\n            throw new Error('Hash property is required for mixin reference. eg. mixin#name');\n        }\n        if (!context.note.mixin || !context.note.mixin[this.node.hash]) {\n            throw new Error(`Mixin #${this.node.hash} is not defined`);\n        }\n        const def = context.note.mixin[this.node.hash];\n        const ctx = context.sub();\n        def.nodes.forEach(it => ctx.compileUp(it, this.stack, -2));\n        const output = ctx.getOutput();\n        const actual = Object.assign({}, def.replacement, this.replacement(context));\n        const o = Object.keys(actual).reduce((acc, item) => {\n            return acc.replace(new RegExp(`\\\\$${item}`, 'g'), actual[item]);\n        }, output);\n        context.push(o);\n    }\n}\nexports.MixinReferenceCompiler = MixinReferenceCompiler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst sleet_1 = require(\"sleet\");\nconst tag_1 = require(\"./compilers/tag\");\nconst text_1 = require(\"./compilers/text\");\nconst other_tags_1 = require(\"./compilers/other-tags\");\nconst values_1 = require(\"./compilers/values\");\nconst attribute_1 = require(\"./compilers/attribute\");\nconst include_1 = require(\"./compilers/include\");\nconst mixin_1 = require(\"./compilers/mixin\");\nexports.plugin = {\n    prepare(context) {\n        context.register(tag_1.TagCompiler, text_1.TextCompiler, tag_1.EmptyTagCompiler, other_tags_1.CommentCompiler, other_tags_1.DoctypeCompiler, other_tags_1.IeifCompiler, other_tags_1.EchoCompiler, mixin_1.MixinDefineCompiler, mixin_1.MixinReferenceCompiler);\n        context.register(values_1.StringValueCompiler, values_1.BooleanValueCompiler, values_1.NumberValueCompiler, values_1.IdentifierValueCompiler);\n        context.register(attribute_1.AttributeGroupCompiler, attribute_1.AttributeCompiler);\n        context.register(include_1.IncludeCompiler);\n    },\n    compile(input, options, context) {\n        const { nodes, declaration } = input;\n        nodes.forEach(it => context.compileUp(it, new sleet_1.SleetStack(), -1));\n        return {\n            code: context.getOutput(),\n            extension: (declaration && declaration.extension) || 'html'\n        };\n    }\n};\n","import { TagCompiler } from 'sleet-html/lib/compilers/tag'\nimport { SleetNode, Compiler, Tag, SleetStack, Context, compile } from 'sleet'\n\nexport class BlockTagCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        const tag = node as Tag\n        if (tag.name && stack.note('blocks').indexOf(tag.name) !== -1) return new BlockTagCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context, elseNode?: SleetNode) {\n        this.tagOpen(context)\n        this.content(context)\n        if (elseNode) {\n            context.eol().indent().push('{{else}}')\n            context.compileUp(elseNode, this.stack, -1)\n        }\n        this.tagClose(context)\n    }\n\n    openStart (context: Context) {\n        context.eol().indent().push('{{#').push(this.node.name!)\n    }\n\n    openEnd (context: Context) {\n        context.push('}}')\n    }\n\n    tagClose (context: Context) {\n        if (this.selfClosing()) return\n        if (context.haveIndent) context.eol().indent()\n        context.push(`{{/${this.node.name!}}}`)\n    }\n}\n\nexport class ElseCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name !== 'else') return\n        return new ElseCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        super.content(context)\n    }\n}\n","import { AttributeCompiler } from 'sleet-html/lib/compilers/attribute'\nimport {\n    SleetNode, SleetStack, Compiler, Attribute, Context, NodeType, Tag,\n    StringValue, IdentifierValue, AttributeGroup, Setting, AbstractCompiler, Helper\n} from 'sleet'\n\nconst isInDynamic = (stack: SleetStack): boolean => {\n    if (stack.last(NodeType.Setting)) return true\n    if (stack.last(NodeType.TransformValue)) return true\n    const h = stack.last(NodeType.Helper)\n    if (h && (h.node as Helper).name && !h.note.content) return true\n\n    const s = stack.last(NodeType.Tag)\n    if (!s || !(s.node as Tag).name) return false\n    const tag = s.node as Tag\n    if (!tag.name) return false\n    if (stack.note('blocks').indexOf(tag.name) !== -1) return true\n    if (stack.note('inlines').indexOf(tag.name) !== -1) return true\n    if (tag.name.slice(0, 1) === '@' && stack.note('inlines').indexOf(tag.name.slice(1)) !== -1) return true\n    return false\n}\n\nexport class DynamicAttributeCompiler extends AttributeCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if (isInDynamic(stack)) return new DynamicAttributeCompiler(node as Attribute, stack)\n    }\n\n    compile (context: Context) {\n        const key = this.key(context)\n        const value = this.value(context)\n\n        if (key) context.push(key).push('=').push(value)\n        else context.push(value)\n    }\n}\n\nexport class StringValueCompiler extends AbstractCompiler<StringValue> {\n    static type = NodeType.StringValue\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if (isInDynamic(stack)) return new StringValueCompiler(node as StringValue, stack)\n    }\n\n    compile (context: Context) {\n        context.push(`\"${this.node.value}\"`)\n    }\n}\n\nexport class IdentifierValueCompiler extends AbstractCompiler<IdentifierValue> {\n    static type = NodeType.IdentifierValue\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if (!isInDynamic(stack)) return new IdentifierValueCompiler(node as IdentifierValue, stack)\n    }\n\n    compile (context: Context) {\n        const s = this.stack.last(NodeType.Tag)!\n        context.push(s.note.noEscape ? `{{{${this.node.value}}}}` : `{{${this.node.value}}}`)\n    }\n}\n\nexport class SettingGroupCompiler extends AbstractCompiler<AttributeGroup> {\n    static type = NodeType.AttributeGroup\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if (!(node as AttributeGroup).setting) return\n        return new SettingGroupCompiler(node as AttributeGroup, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.node.setting) return\n        const compiler = context.create(this.node.setting, this.stack)\n        if (!compiler) return\n        const sub = context.sub()\n        compiler.compile(sub, this.node)\n        sub.mergeUp()\n    }\n}\n\nexport class GroupSettingCompiler implements Compiler {\n    static type = NodeType.Setting\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new GroupSettingCompiler(node as Setting, stack)\n    }\n\n    private node: Setting\n    private stack: SleetStack\n\n    constructor(node: Setting, stack: SleetStack) {\n        this.node = node\n        this.stack = stack\n    }\n\n    compile (context: Context, group: AttributeGroup) {\n        context.push('{{#').push(this.node.name)\n        const stack = this.stack.concat(this.node)\n        if (this.node.attributes.length) context.push(' ')\n        this.node.attributes.forEach((it, idx) => {\n            const sub = context.compile(it, stack)\n            if (sub) {\n                if (idx) context.push(' ')\n                sub.mergeUp()\n            }\n        })\n        context.push('}}')\n\n        group.attributes.forEach((it, idx) => {\n            const sub = context.compile(it, this.stack)\n            if (sub) {\n                if (idx) context.push(' ')\n                sub.mergeUp()\n            }\n        })\n        context.push(`{{/${this.node.name}}}`)\n    }\n}\n","import { TagCompiler } from 'sleet-html/lib/compilers/tag'\nimport { EchoCompiler } from 'sleet-html/lib/compilers/other-tags'\n\nimport { Context, SleetNode, SleetStack, Compiler, Tag } from 'sleet'\nimport { BlockTagCompiler } from './block-tag'\n\nexport function compileTags (context: Context, tags: Tag[], stack: SleetStack, indent = 0) {\n    let i = 0\n    while (i < tags.length) {\n        const item = tags[i]\n        const next = tags[i + 1]\n        if (!next || next.name !== 'else') {\n            context.compileUp(item, stack, indent)\n            i ++\n            continue\n        }\n\n        const c = context.create(item, stack)\n        if (!c || !(c instanceof BlockTagCompiler)) {\n            const { start } = item.location\n            throw new SyntaxError(`not paired else tag, line: ${start.line}, column: ${start.column}`)\n        }\n        const sub = context.sub(indent)\n        c.compile(sub, next)\n        sub.mergeUp()\n        i += 2\n    }\n}\n\nexport class HandlebarsTagCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new HandlebarsTagCompiler(node as Tag, stack)\n    }\n\n    content (context: Context) {\n        if (this.selfClosing()) return\n        compileTags(context, this.node.children, this.stack)\n    }\n}\n\nexport class AtEchoCompiler extends EchoCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === '@echo') return new AtEchoCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        const s = this.stack.last()!\n        s.note.noEscape = true\n        super.compile(context)\n    }\n}\n","import { TagCompiler } from 'sleet-html/lib/compilers/tag'\nimport { SleetNode, SleetStack, Compiler, Tag, Context } from 'sleet'\n\nexport class InlineTagCompiler extends TagCompiler {\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        const tag = node as Tag\n        if (!tag.name) return\n\n        let escape = true\n        let name = tag.name\n\n        if (name.slice(0, 1) === '@') {\n            name = name.slice(1)\n            escape = false\n        }\n\n        if (stack.note('inlines').indexOf(name) !== -1) return new InlineTagCompiler(node as Tag, stack, !escape)\n    }\n\n    readonly noEscape: boolean\n\n    constructor(node: Tag, stack: SleetStack, noEscape: boolean) {\n        super(node, stack)\n        this.noEscape = noEscape\n    }\n\n    openStart (context: Context) {\n        if (!this.node.name) return\n        context.eol().indent().push(this.noEscape ? '{{{' : '{{')\n        context.push(this.noEscape ? this.node.name.slice(1) : this.node.name)\n    }\n\n    openEnd (context: Context) {\n        context.push(this.noEscape ? '}}}' : '}}')\n    }\n\n    selfClosing () {\n        return true\n    }\n}\n","import {\n    AbstractCompiler, Helper, Context, NodeType, SleetNode, SleetStack, Compiler,\n    HelperAttribute, Attribute, CompareOperatorValue\n} from 'sleet'\n\nexport class HelperCompiler extends AbstractCompiler<Helper> {\n    static type = NodeType.Helper\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new HelperCompiler(node as Helper, stack)\n    }\n\n    count: number\n\n    constructor (node: Helper, stack: SleetStack, count: number = 1) {\n        super(node, stack)\n        this.count = count\n    }\n\n    compile (context: Context) {\n        if (!this.node.name) {\n            this.noName(context)\n            return\n        }\n\n        const helpers = this.stack.note('helpers') as {[name: string]: number}\n        const count = helpers[this.node.name] || 1\n        const cs = this.node.attributes.slice(0, count)\n        const remain = this.node.attributes.slice(count)\n\n        const ctx = context.sub()\n        cs.map((it, idx) => {\n            if (idx) ctx.push(' ')\n            ctx.compileUp(it, this.stack)\n        })\n        if (!remain.length) {\n            context.push(`{{${this.node.name} ${ctx.getOutput()}}}`)\n            return\n        }\n\n        const o = this.stack.last()!\n        o.note.content = true\n\n        context.push(`{{#${this.node.name} ${ctx.getOutput()}}}`)\n        const c = ctx.compile(remain[0], this.stack)\n        const cc = c ? c.getOutput() : ''\n        context.push(cc)\n\n        if (remain.length > 1) {\n            const ctx2 = context.sub()\n            remain.slice(1).map(it => ctx2.compileUp(it, this.stack))\n            const ccc = ctx2.getOutput()\n            context.push(`{{else}}${ccc}`)\n        }\n        context.push(`{{/${this.node.name}}`)\n    }\n\n    noName (context: Context) {\n        const attr = this.stack.last(NodeType.Attribute)\n        const needSpace = attr && (attr.node as Attribute).name === 'class'\n        this.node.attributes.forEach((it, idx) => {\n            const c = context.compile(it, this.stack)\n            if (c) {\n                if (idx && needSpace) context.push(' ')\n                c.mergeUp()\n            }\n        })\n    }\n}\n\nexport class HelperAttributeCompiler extends AbstractCompiler<HelperAttribute> {\n    static type = NodeType.HelperAttribute\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new HelperAttributeCompiler(node as HelperAttribute, stack)\n    }\n\n    compile (context: Context) {\n        context.compileUp(this.node.value, this.stack)\n    }\n}\n\nexport class CompareOperatorCompiler extends AbstractCompiler<CompareOperatorValue> {\n    static type = NodeType.CompareOperator\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new CompareOperatorCompiler(node as CompareOperatorValue, stack)\n    }\n\n    compile (context: Context) {\n        context.push(`\"${this.node.value}\"`)\n    }\n}\n","import {\n    AbstractCompiler, Tag, NodeType, SleetStack, SleetNode,\n    Compiler, Context, StaticText, DynamicText\n} from 'sleet'\n\nexport class HandlebarsTextCompiler extends AbstractCompiler<Tag> {\n    static type = NodeType.Tag\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        if ((node as Tag).name === '|') return new HandlebarsTextCompiler(node as Tag, stack)\n    }\n\n    compile (context: Context) {\n        if (!this.node.text.length) return\n\n        const lines = this.node.text.filter(it => !!it.length)\n        if (!this.inline()) context.eol()\n        lines.forEach(line => {\n            if (!line.map(it => it.toHTMLString()).join('').length) {\n                context.eol()\n                return\n            }\n\n            if (!this.inline()) context.indent()\n            line.forEach(it => context.compileUp(it, this.stack))\n            context.eol()\n        })\n        context.pop()\n    }\n\n    inline () {\n        return this.node.namespace === 'inline'\n    }\n}\n\nexport class StaticTextCompiler extends AbstractCompiler<StaticText> {\n    static type = NodeType.StaticText\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new StaticTextCompiler(node as StaticText, stack)\n    }\n\n    compile (context: Context) {\n        context.push(this.node.toHTMLString())\n    }\n}\n\nexport class DynamicTextCompiler extends AbstractCompiler<DynamicText> {\n    static type = NodeType.DynamicText\n    static create (node: SleetNode, stack: SleetStack): Compiler | undefined {\n        return new DynamicTextCompiler(node as DynamicText, stack)\n    }\n\n    compile (context: Context) {\n        context.compileUp(this.node.value, this.stack)\n    }\n}\n","import { SleetPlugin, Context, SleetOutput, SleetOptions, CompileResult, SleetStack } from 'sleet'\nimport { plugin as html } from 'sleet-html'\nimport { TagCompiler } from 'sleet-html/lib/compilers/tag'\nimport { TextCompiler } from 'sleet-html/lib/compilers/text'\n\nimport { BlockTagCompiler, ElseCompiler } from './compilers/block-tag'\nimport {\n    DynamicAttributeCompiler, StringValueCompiler,\n    IdentifierValueCompiler, GroupSettingCompiler,\n    SettingGroupCompiler\n} from './compilers/attributes'\nimport { HandlebarsTagCompiler, compileTags, AtEchoCompiler } from './compilers/tag'\nimport { InlineTagCompiler } from './compilers/inline-tag'\nimport { HelperCompiler, HelperAttributeCompiler, CompareOperatorCompiler } from './compilers/helper'\nimport { HandlebarsTextCompiler, StaticTextCompiler, DynamicTextCompiler } from './compilers/text'\n\nexport const plugin = {\n    prepare (context: Context) {\n        if (html.prepare) html.prepare(context)\n        context.replace(TagCompiler, HandlebarsTagCompiler)\n        context.replace(TextCompiler, HandlebarsTextCompiler)\n        context.register(BlockTagCompiler, ElseCompiler, InlineTagCompiler)\n        context.register(HelperCompiler, HelperAttributeCompiler)\n        context.register(DynamicAttributeCompiler, StringValueCompiler, IdentifierValueCompiler)\n        context.register(GroupSettingCompiler, SettingGroupCompiler)\n        context.register(AtEchoCompiler, StaticTextCompiler, DynamicTextCompiler)\n        context.register(CompareOperatorCompiler)\n    },\n\n    compile (input: CompileResult, options: SleetOptions, context: Context): SleetOutput {\n        const {nodes, declaration} = input\n        const helpers: {[name: string]: number} = {}\n        const blocks = ['if', 'each', 'unless', 'with']\n        const inlines: string[] = []\n\n        if (options.pluginOptions && options.pluginOptions.handlebars) {\n            const opt = options.pluginOptions.handlebars\n            if (Array.isArray(opt.block)) {\n                (opt.block as string[]).forEach(it => blocks.push(it))\n            }\n            if (Array.isArray(opt.inline)) {\n                (opt.inline as string[]).forEach(it => inlines.push(it))\n            }\n            if (opt.helper) {\n                Object.assign(helpers, opt.helper)\n            }\n        }\n\n        if (declaration) {\n            (declaration.option('block') || '').split(',').forEach(it => {\n                if (it.trim()) blocks.push(it.trim())\n            });\n            (declaration.option('inline') || '').split(',').forEach(it => {\n                if (it.trim()) inlines.push(it.trim())\n            });\n            (declaration.option('helper') || '').split(',').forEach(it => {\n                const [name, count] = it.split(':')\n                helpers[name.trim()] = Number(count) || 1\n            })\n        }\n\n        compileTags(context, nodes, new SleetStack([], {blocks, inlines, helpers}), -1)\n\n        return {\n            code: context.getOutput(),\n            extension: (declaration && declaration.extension) || 'hbs'\n        }\n    }\n} as SleetPlugin\n"],"names":["defineProperty","exports","value","TagCompiler","context","tagOpen","content","tagClose","openStart","attributes","openEnd","eol","indent","push","this","node","namespace","name","groups","mergeAttributeGroup","dotsAndHash","concat","attributeGroups","length","forEach","it","idx","sub","compile","_this2","stack","mergeUp","selfClosing","children","compileUp","_this3","haveIndent","hash","dots","s","location","start","e","end","offset","line","column","attrs","sleet_1","StringValue","Attribute","undefined","map","AttributeGroup","gs","filter","options","ignoreSetting","reduce","acc","item","merge","ns","setting","AbstractCompiler","type","NodeType","Tag","emptyTags","EmptyTagCompiler","tag","indexOf","TextCompiler","text","escape","lines","inline","txt","toHTMLString","join","replace","pop","CommentCompiler","tag_1","DoctypeCompiler","IeifCompiler","closeIt","attr","values","v","EchoCompiler","_this5","ValueCompiler","StringValueCompiler","BooleanValueCompiler","BooleanValue","NumberValueCompiler","NumberValue","IdentifierValueCompiler","IdentifierValue","AttributeGroupCompiler","AttributeCompiler","k","key","result","vs","_this4","getOutput","IncludeCompiler","dir","sourceFile","path","resolve","fs","statSync","isFile","dirname","file","getPath","parse","readFileSync","nodes","SyntaxError","MixinDefineCompiler","Error","note","mixin","replacement","vv","MixinReferenceCompiler","def","ctx","output","actual","Object","assign","o","keys","RegExp","register","text_1","other_tags_1","mixin_1","values_1","attribute_1","include_1","input","declaration","SleetStack","extension","BlockTagCompiler","elseNode","ElseCompiler","isInDynamic","last","Setting","TransformValue","h","Helper","slice","DynamicAttributeCompiler","noEscape","SettingGroupCompiler","compiler","create","GroupSettingCompiler","group","compileTags","tags","i","next","c","HandlebarsTagCompiler","AtEchoCompiler","InlineTagCompiler","HelperCompiler","count","cs","remain","cc","ctx2","ccc","noName","needSpace","HelperAttributeCompiler","HelperAttribute","CompareOperatorCompiler","CompareOperator","HandlebarsTextCompiler","StaticTextCompiler","StaticText","DynamicTextCompiler","DynamicText","plugin","html","prepare","helpers","blocks","inlines","pluginOptions","handlebars","opt","Array","isArray","block","helper","option","split","trim","Number"],"mappings":"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"}